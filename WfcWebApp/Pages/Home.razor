@page "/"
@using WfcWebApp.Wfc
@using WfcWebApp.Utils
@using Microsoft.AspNetCore.Components.Forms

<PageTitle>Texture Generator</PageTitle>

<h3>Texture Generator</h3>
<p>
    Generate seamless, wrapping textures of any size using wave function collapse!<br/>
    Upload a suitable input texture below, or draw one yourself!
</p>

<h3>Select a Pattern</h3>

<div class="pattern-picker">
	@foreach (var pattern in SamplePatterns)
	{
		<img src="@pattern.ImagePath"
		     title="@pattern.Name"
		     class="pattern-thumb @(SelectedPattern?.ImagePath == pattern.ImagePath ? "selected" : "")"
		     @onclick="() => SelectPattern(pattern)" />
	}

	<label class="pattern-thumb upload-thumb">
		<span>+</span>
		<InputFile OnChange="HandleUpload" style="display:none" />
	</label>
</div>

@if (SelectedImageDataUrl is not null)
{
	<h4>Selected Pattern:</h4>
	<img src="@SelectedImageDataUrl" class="preview-canvas" />
}

<WfcParameters @ref="parametersRef"/>
<WfcGenerator
    @ref="generatorRef"
    PaletteImage="@userInputImage"
    OnStepComplete="@OnGenerationStep"
    Parameters="@parametersRef"
    />
<div style="display: flex; gap: 8px; align-items: start;">
	<SwatchImageCanvas @ref="swatchCanvasRef" />
	<SwatchImageCanvas @ref="entropyCanvasRef" />
</div>
<button @onclick="DumpTimers">Dump Timers</button>

@code {
// UI TODOS:
/*
get rid of the editable canvas thing
replace with several samples the user can select, like the red shape, redpath, flowers, stuff from the original github
or upload your own!
that way people can play with the samples, and if theyre more serious, they can upload their own pixel art
*/
    private class Pattern
	{
		public string Name { get; set; }
		public string ImagePath { get; set; }
	}

	private List<Pattern> SamplePatterns = new()
	{
		new Pattern { Name = "Angular", ImagePath = "sample-patterns/angular.png" },
		new Pattern { Name = "Lake", ImagePath = "sample-patterns/lake.png" },
		new Pattern { Name = "Village", ImagePath = "sample-patterns/village2.png" }
	};

	private Pattern? SelectedPattern;
	private string? SelectedImageDataUrl;

	private void SelectPattern(Pattern pattern)
	{
		SelectedPattern = pattern;
		SelectedImageDataUrl = pattern.ImagePath;
	}

	private async Task HandleUpload(InputFileChangeEventArgs e)
	{
		var file = e.File;
		var buffer = new byte[file.Size];
		await file.OpenReadStream().ReadAsync(buffer);
		var base64 = Convert.ToBase64String(buffer);
		SelectedImageDataUrl = $"data:{file.ContentType};base64,{base64}";
		SelectedPattern = null;
	}

    private WfcGenerator generatorRef;
    private WfcParameters parametersRef;
    private IndexedImage userInputImage = IndexedImage.CreateBlank(32, 32);

    private void HandleImageChanged(IndexedImage image) {
        userInputImage = image;
        outputImage = null;
        entropyImage = null;
        generatorRef.Reset();
    }

    private void DumpTimers() {
        StopwatchManager.Dump();
    }

    private SwatchImage? outputImage = null;
    private SwatchImage? entropyImage = null;
    private SwatchImageCanvas swatchCanvasRef = default!;
    private SwatchImageCanvas entropyCanvasRef = default!;

    private int spacing = 1;
    private async Task OnGenerationStep(Generator.StepResult result) {
        Console.WriteLine($"Just finished {result} step.");
        if (outputImage == null) {
            WfcConfig config = generatorRef.Parameters.GetConfig();
            outputImage = new(config.OutputWidth*spacing, config.OutputHeight*spacing);
            entropyImage = new(config.OutputWidth, config.OutputHeight);
            swatchCanvasRef.SetImage(outputImage);
            entropyCanvasRef.SetImage(entropyImage);
        }
        WaveVisualizer.RenderToImage(generatorRef.wfcGenerator.Wave, generatorRef.wfcGenerator.Palette, outputImage, spacing);
        WaveVisualizer.RenderToEntropy(generatorRef.wfcGenerator, entropyImage);
        await swatchCanvasRef.Rerender();
        await entropyCanvasRef.Rerender();
        
        // Force visual update *now*
        StateHasChanged();
        await Task.Yield(); // yields control so rendering can happen
    }

}

